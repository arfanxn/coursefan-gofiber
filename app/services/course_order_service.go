package services

import (
	"net/url"
	"os"
	"strconv"
	"time"

	"github.com/arfanxn/coursefan-gofiber/app/enums"
	"github.com/arfanxn/coursefan-gofiber/app/helpers/ctxh"
	"github.com/arfanxn/coursefan-gofiber/app/helpers/errorh"
	"github.com/arfanxn/coursefan-gofiber/app/helpers/sliceh"
	"github.com/arfanxn/coursefan-gofiber/app/http/requests"
	"github.com/arfanxn/coursefan-gofiber/app/models"
	"github.com/arfanxn/coursefan-gofiber/app/repositories"
	"github.com/arfanxn/coursefan-gofiber/resources"
	"github.com/gofiber/fiber/v2"
	"github.com/google/uuid"
	"github.com/midtrans/midtrans-go"
	"github.com/midtrans/midtrans-go/coreapi"
	"gopkg.in/guregu/null.v4"
)

type CourseOrderService struct {
	repository       *repositories.CourseOrderRepository
	courseRepository *repositories.CourseRepository
	curRepository    *repositories.CourseUserRoleRepository
	roleRepository   *repositories.RoleRepository
}

func NewCourseOrderService(
	repository *repositories.CourseOrderRepository,
	courseRepository *repositories.CourseRepository,
	curRepository *repositories.CourseUserRoleRepository,
	roleRepository *repositories.RoleRepository,
) *CourseOrderService {
	return &CourseOrderService{
		repository:       repository,
		courseRepository: courseRepository,
		curRepository:    curRepository,
		roleRepository:   roleRepository,
	}
}

// All
func (service *CourseOrderService) All(c *fiber.Ctx, input requests.Query) (
	pagination resources.Pagination[resources.CourseOrder], err error) {
	coMdls, err := service.repository.All(c, input)
	if err != nil {
		return
	}
	coRess := sliceh.Map(coMdls, func(coMdl models.CourseOrder) resources.CourseOrder {
		coRes := resources.CourseOrder{}
		coRes.FromModel(coMdl)
		return coRes
	})
	pagination.SetItems(coRess)
	pagination.SetPageFromOffsetLimit(int64(input.Offset), int(input.Limit.Int64))
	pagination.SetURL(errorh.Must(url.Parse(ctxh.GetFullURIString(c))))
	return
}

// Create
func (service *CourseOrderService) Create(c *fiber.Ctx, input requests.CourseOrderCreate) (
	result struct {
		CoreapiChargeResponse coreapi.ChargeResponse
		ResourceCourseOrder   resources.CourseOrder
	},
	err error,
) {

	courseMdl, err := service.courseRepository.FindById(c, input.CourseId)
	if errorh.IsGormErrRecordNotFound(err) {
		err = fiber.ErrNotFound
		return
	} else if err != nil {
		return
	}

	// Prevent duplicate order by checking it against existing orders
	coMdl, err := service.repository.FindByModel(c, models.CourseOrder{
		UserId:   ctxh.MustGetUser(c).Id,
		CourseId: courseMdl.Id,
	})
	if (err != nil) && !errorh.IsGormErrRecordNotFound(err) {
		return
	} else if coMdl.Id != uuid.Nil {
		err = fiber.ErrConflict
		return
	}

	coMdl.UserId = uuid.MustParse(input.UserId)
	coMdl.CourseId = uuid.MustParse(input.CourseId)
	coMdl.Amount = courseMdl.Price
	coMdl.Rate = errorh.Must(strconv.ParseFloat(os.Getenv("MIDTRANS_RATE_BANK_TRANSFER"), 32))
	// TODO: implement discount from discount code on the future
	coMdl.Discount = 0
	coMdl.Total = (coMdl.Amount - coMdl.Discount) + coMdl.Rate // total of amount, discount and rate
	_, err = service.repository.Insert(c, &coMdl)
	if err != nil {
		return
	}

	// Midtrans object
	bankTransferDetails := coreapi.BankTransferDetails{
		Bank:     midtrans.Bank(input.Bank),
		VaNumber: "111111", // VA number will be generated by midtrans
	}
	customerDetails := midtrans.CustomerDetails{
		FName: ctxh.MustGetUser(c).FirstName(),
		LName: ctxh.MustGetUser(c).LastName(),
		Email: ctxh.MustGetUser(c).Email,
	}
	transactionDetails := midtrans.TransactionDetails{
		OrderID:  coMdl.Id.String(),
		GrossAmt: int64(coMdl.Total),
	}
	itemDetails := []midtrans.ItemDetails{{
		ID:    input.CourseId,
		Price: int64(coMdl.Total),
		Qty:   1,
		Name:  courseMdl.Name,
	}}
	chargeReq := &coreapi.ChargeReq{
		PaymentType:        coreapi.PaymentTypeBankTransfer,
		TransactionDetails: transactionDetails,
		CustomerDetails:    &customerDetails,
		BankTransfer:       &bankTransferDetails,
		Items:              &itemDetails,
	}
	coreapiChargeResponse, midtransErr := coreapi.ChargeTransaction(chargeReq)
	if midtransErr != nil {
		return
	}

	result.CoreapiChargeResponse = *coreapiChargeResponse
	result.ResourceCourseOrder.FromModel(coMdl)
	return
}

// Find
func (service *CourseOrderService) Find(c *fiber.Ctx, input requests.Query) (
	data resources.CourseOrder, err error) {
	coMdls, err := service.repository.All(c, input)
	if err != nil {
		return
	} else if len(coMdls) == 0 {
		err = fiber.ErrNotFound
		return
	}
	data.FromModel(coMdls[0])
	return
}

// UpdateByMidtransNotification
func (service *CourseOrderService) UpdateByMidtransNotification(c *fiber.Ctx, input requests.MidtransNotification) (coRes resources.CourseOrder, err error) {
	// Get order id from input
	orderId := input.OrderId
	if orderId == "" {
		err = fiber.ErrUnprocessableEntity
		return
	}

	// Find CourseOrder
	coMdl, err := service.repository.FindById(c, orderId)
	if errorh.IsGormErrRecordNotFound(err) {
		err = fiber.ErrNotFound
		return
	} else if err != nil {
		return
	}

	// Check transaction to Midtrans with param orderId
	transactionStatusResp, midtransErr := coreapi.CheckTransaction(orderId)
	if midtransErr != nil {
		err = midtransErr
		return
	} else if transactionStatusResp == nil {
		err = fiber.ErrInternalServerError
		return
	}

	// Reset CourseOrder status
	coMdl.CancelledAt = null.Time{}
	coMdl.ChargebackedAt = null.Time{}
	coMdl.ExpiredAt = null.Time{}
	coMdl.FailedAt = null.Time{}
	coMdl.RefundedAt = null.Time{}
	coMdl.SettledAt = null.Time{}

	// ----------------------------------------------------------------
	// Do set transaction status based on response from check transaction status
	if transactionStatusResp.TransactionStatus == "capture" {
		if transactionStatusResp.FraudStatus == "challenge" {
			// This condition only passed if the payment method is using credit card,
			// set transaction status on your database to 'challenge'
			// ? should we implement the credit card payment method in the future?
		}
		if transactionStatusResp.FraudStatus == "accept" {
			// Set transaction status on your database to 'success'
			coMdl.SettledAt = null.NewTime(time.Now(), true)
		}
	}
	if transactionStatusResp.TransactionStatus == "settlement" {
		// Set transaction status on your databaase to 'success'
		coMdl.SettledAt = null.NewTime(time.Now(), true)
	}
	if transactionStatusResp.TransactionStatus == "deny" {
		// you can ignore 'deny', because most of the time it allows payment retries
		// and later can become success
		// ? should we prefer to ignore this one?
	}
	if sliceh.Contains([]string{"cancel", "expire"}, transactionStatusResp.TransactionStatus) {
		// set transaction status on your databaase to 'failure'
		coMdl.FailedAt = null.NewTime(time.Now(), true)
	}
	if transactionStatusResp.TransactionStatus == "cancel" {
		coMdl.CancelledAt = null.NewTime(time.Now(), true)
	}
	if transactionStatusResp.TransactionStatus == "expire" {
		coMdl.ExpiredAt = null.NewTime(time.Now(), true)
	}
	if transactionStatusResp.TransactionStatus == "pending" {
		coMdl.ChargebackedAt = null.NewTime(time.Now(), true)
	}
	// ----------------------------------------------------------------

	// Update the CourseOrder
	_, err = service.repository.UpdateById(c, &coMdl)
	if err != nil {
		return
	}

	// If the order/transaction is settled, then give a user role&permissions to access the course that user has purchased previously
	if coMdl.SettledAt.Valid {
		// Get participant role
		var roleMdl models.Role
		roleMdl, err = service.roleRepository.FindByName(c, enums.RoleNameCourseParticipant)
		if err != nil {
			return
		}

		// Give the user a participant role to access the purchased course
		var curMdl models.CourseUserRole
		curMdl, err = service.curRepository.FindByModel(c, models.CourseUserRole{
			CourseId: coMdl.CourseId,
			UserId:   coMdl.UserId,
		})
		curMdl.CourseId = coMdl.CourseId
		curMdl.UserId = coMdl.UserId
		curMdl.RoleId = roleMdl.Id
		if errorh.IsGormErrRecordNotFound(err) {
			_, err = service.curRepository.Insert(c, &curMdl)
			if err != nil {
				return
			}
			return
		} else if err != nil {
			return
		} else if curMdl.Id != uuid.Nil {
			_, err = service.curRepository.UpdateById(c, &curMdl)
			if err != nil {
				return
			}
		}
	}

	coRes.FromModel(coMdl)
	return
}
