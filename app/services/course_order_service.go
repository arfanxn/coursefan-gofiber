package services

import (
	"net/url"
	"time"

	"github.com/arfanxn/coursefan-gofiber/app/helpers/ctxh"
	"github.com/arfanxn/coursefan-gofiber/app/helpers/errorh"
	"github.com/arfanxn/coursefan-gofiber/app/helpers/sliceh"
	"github.com/arfanxn/coursefan-gofiber/app/http/requests"
	"github.com/arfanxn/coursefan-gofiber/app/models"
	"github.com/arfanxn/coursefan-gofiber/app/repositories"
	"github.com/arfanxn/coursefan-gofiber/resources"
	"github.com/gofiber/fiber/v2"
	"github.com/google/uuid"
	"github.com/midtrans/midtrans-go"
	"github.com/midtrans/midtrans-go/coreapi"
	"gopkg.in/guregu/null.v4"
)

type CourseOrderService struct {
	repository       *repositories.CourseOrderRepository
	courseRepository *repositories.CourseRepository
}

func NewCourseOrderService(
	repository *repositories.CourseOrderRepository,
	courseRepository *repositories.CourseRepository,
) *CourseOrderService {
	return &CourseOrderService{
		repository:       repository,
		courseRepository: courseRepository,
	}
}

// All
func (service *CourseOrderService) All(c *fiber.Ctx, input requests.Query) (
	pagination resources.Pagination[resources.CourseOrder], err error) {
	coMdls, err := service.repository.All(c, input)
	if err != nil {
		return
	}
	coRess := sliceh.Map(coMdls, func(coMdl models.CourseOrder) resources.CourseOrder {
		coRes := resources.CourseOrder{}
		coRes.FromModel(coMdl)
		return coRes
	})
	pagination.SetItems(coRess)
	pagination.SetPageFromOffsetLimit(int64(input.Offset), int(input.Limit.Int64))
	pagination.SetURL(errorh.Must(url.Parse(ctxh.GetFullURIString(c))))
	return
}

// Create
func (service *CourseOrderService) Create(c *fiber.Ctx, input requests.CourseOrderCreate) (
	result struct {
		CoreapiChargeResponse coreapi.ChargeResponse
		ResourceCourseOrder   resources.CourseOrder
	},
	err error,
) {

	courseMdl, err := service.courseRepository.FindById(c, input.CourseId)
	if errorh.IsGormErrRecordNotFound(err) {
		err = fiber.ErrNotFound
		return
	} else if err != nil {
		return
	}

	coMdl := models.CourseOrder{}
	coMdl.UserId = uuid.MustParse(input.UserId)
	coMdl.CourseId = uuid.MustParse(input.CourseId)
	coMdl.Amount = courseMdl.Price
	coMdl.Rate = 1000                                          // TODO: get rate based on environment variable
	coMdl.Discount = 20000                                     // TODO: implement discount from discount code on the future
	coMdl.Total = (coMdl.Amount - coMdl.Discount) + coMdl.Rate // total of amount, discount and rate
	coMdl.SettledAt = null.TimeFrom(time.Now())                // TODO: check whether settlement is already done from midtrans weebhook
	_, err = service.repository.Insert(c, &coMdl)
	if err != nil {
		return
	}

	// Midtrans object
	bankTransferDetails := coreapi.BankTransferDetails{
		Bank:     midtrans.Bank(input.Bank),
		VaNumber: "111111", // VA number will be generated by midtrans
	}
	customerDetails := midtrans.CustomerDetails{
		FName: ctxh.MustGetUser(c).FirstName(),
		LName: ctxh.MustGetUser(c).LastName(),
		Email: ctxh.MustGetUser(c).Email,
	}
	transactionDetails := midtrans.TransactionDetails{
		OrderID:  coMdl.Id.String(),
		GrossAmt: int64(coMdl.Total),
	}
	itemDetails := []midtrans.ItemDetails{{
		ID:    input.CourseId,
		Price: int64(coMdl.Total),
		Qty:   1,
		Name:  courseMdl.Name,
	}}
	chargeReq := &coreapi.ChargeReq{
		PaymentType:        coreapi.PaymentTypeBankTransfer,
		TransactionDetails: transactionDetails,
		CustomerDetails:    &customerDetails,
		BankTransfer:       &bankTransferDetails,
		Items:              &itemDetails,
	}
	coreapiChargeResponse, midtransErr := coreapi.ChargeTransaction(chargeReq)
	if midtransErr != nil {
		return
	}

	result.CoreapiChargeResponse = *coreapiChargeResponse
	result.ResourceCourseOrder.FromModel(coMdl)
	return
}

// Find
func (service *CourseOrderService) Find(c *fiber.Ctx, input requests.Query) (
	data resources.CourseOrder, err error) {
	coMdls, err := service.repository.All(c, input)
	if err != nil {
		return
	} else if len(coMdls) == 0 {
		err = fiber.ErrNotFound
		return
	}
	data.FromModel(coMdls[0])
	return
}
